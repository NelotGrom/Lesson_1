# Lesson_1
ITS_school lesson 1

## GIT Merge and Rebase

'git merge' сохраняет историю коммитов, сливая историю мастера с целевой веткой фичи создавая коммит слияния, поэтому мы можем проследить контекст и всю хронологию.
'git rebase' перемещает коммиты из одной ветки к концу другой, из-за чего хронология коммитов может потеряться, а так же создаёт риски ошибок у других разработчиков на локальных репозиториях.
История коммитов при применении git rebase выглядит проще и понятнее, чем с git merge. 

## GIT Pull and Fetch

### GIT Pull
Для загрузки изменений из удалённого репозиторияв в локальный используется команда 'git pull'. Она скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией. По сути, это выполнение двух операций: 'git fetch' + 'git merge' .

### GIT Fetch
Команда 'git fetch' загружает все изменения с удаленного репозитория, но не применяет их к вашей рабочей директории или текущей ветке. Она обновляет локальную базу данных об удаленном репозитории (origin), загружает все изменения из удаленных веток локально, но оставляет решение, что делать с ними, за пользователем.

---

Отличие pull and fetch в том, что 'git pull' автоматически интегрирует изменения из удаленной ветки в вашу текущую ветку, в то время как 'git fetch' только загружает изменения без их непосредственного применения к вашей рабочей директории. Это дает больше контроля над тем, какие изменения вы интегрируете и когда.

### GIT Add + Commit --amend

Внести изменения в последний коммит можно добавив измененные файлы в отслеживание командой 'git add', а затем объединить их с последним коммитом командой 'git commit --amend'. 

Если мы допустили ошибку в сообщении коммита, можно воспользоваться командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок: 
'git commit --amend -m "Updated message for the previous commit"'
Флаг '--no-edit' позволяет внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.

## GIT Reset

git reset --soft #commit - в локальном репозитории перемещает нас по истории коммитов без изменения файлов и их отслеживания (т.е. сохраняя все три созданных .md),
git reset --mixed #commit - перемещает к состоянию коммита, включая его состояние отслеживаемых файлов, но всё ещё не изменяя\удаляя их,
git reset --hard #commit - перемещает к состоянию коммита, удаляя состояние отслеживаемых файлов и сами файлы.

При этом с ключом --hard нельзя сделать reset на текущий HEAD коммит, a при удалении файла (например делая reset --hard на второй коммит) - об этом файле сохраняется информация (обозначен как deleted), если вернуться к последнему коммиту (создание third.md), и его можно восстановить командой git restore file_name 

 --mixed флаг используется как дефолтный, т.е git reset == git reset --mixed, 
все флаги команды reset отменяют фиксацию последнего коммита и по своему в каждом из случаем работают с таймлайном (историей и указателем HEAD)

## Общепринятые Коммиты 1.0.0-beta.2
Source: https://www.conventionalcommits.org/ru/v1.0.0-beta.2/

Главное

Как разработчики приложений с открытым исходным кодом, использующие слияние (squash) git’а в ветку master должны писать общепринятые сообщения коммитов.

Сообщения коммитов должны иметь следующую структуру:

```
type ([optional - scope]): <краткое описание>
[optional - body]
[optional - footer]
```

Коммиты включают следующие элементы, чтоб сообщить пользователям вашей библиотеки, что они в себе содержат:

    fix: - коммит типа fix, который исправляет баги в вашем коде (он соотносится с PATCH в правилах семантического управления версиями).
    feat: - коммит type feat, который добавляет новую функциональность в ваш код (он соотносится с MINOR в правилах семантического управления версиями).
    BREAKING CHANGE: - коммит, который содержит текст BREAKING CHANGE: в начале своего необязательного тела или подвала, и несет в себе описание нарушений обратной совместимости в API (он соотносится с MAJOR в правилах семантического управления версиями). BREAKING CHANGE может быть частью коммита любого типа.

Другие: коммиты, отличные от fix: и feat: так же разрешены, например, commitlint-config-conventional(основанный на the Angular convention) рекомендует chore:, docs:, style:, refactor:, perf:, test: идругие. Мы так же рекомендуем improvement для коммитов, которые улучшают текущую реализацию бездобавления новой функциональности или исправления ошибок. Обратите внимание, что данный тип коммитов неуправляется данной спецификацией и не имеет никакого соотношения в правилах семантического управленияверсиями (за исключением случае, если он не содержит в себе BREAKING CHANGE). Область (scope) можетбыть определена для любого типа коммита, чтоб описать контекст коммита. Она содержится в круглыхскобках, например, feat(parser): add ability to parse arrays.
